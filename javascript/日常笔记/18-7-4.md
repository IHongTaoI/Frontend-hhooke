## ES6 class的继承使用细节
```javascript
class Animal{
	constructor(color){
		this.color = color;
	};
}
class Bear extends Animal{
	constructor(){
		super();
	}

```
> ES6子类继承父类，必须在constructor函数的第一行调用super();之后才能使用关键字this，这是因为子类中没有自己的this对象，而是继承父类的this对象，然后才能为这个this添加相应的属性和方法。不然就会报错，相当于Parent.apply(this);而SE5则正好和这个相反，它先创造了自己的this对象，然后才添加父类的方法属性到这个对象里。

super在子类中一般有三种作用

- 作为父类的构造函数调用，就是上面所说的那种方法。
- 在普通方法中，作为父类的实例调用
- 在静态方法中，作为父类调用

在普通方法中调用，此时指向父类的实例
```javascript

class Animal{
	constructor(color){
		this.color = color;
	}
	run(){
		return "run";
	}
}
class Bear extends Animal{
	constructor(){
		super();
		console.log(super.run());
	}
```

在静态方法中调用，此时指向父类
```javascript

class Animal{
	constructor(color){
		this.color = color;
	}
	run(){
		return "run";
	}
	static run(){
		return "static run"
	}
}
class Bear extends Animal{
	constructor(){
		super();
		console.log(super.run());//run
	}
	static go(){
		super.run();//static run
	}
}
```
----
## 扩展运算符

**1.合并数组**

```javascript
arr1.push(...arr2) // 把arr2合并到arr1的后面
arr1.unshift(...arr2) //把arr2合并到arr1的前面
```
如果你想在数组内合并数组，你可以像下面这样做：

```javascript
var arr1 = ['two', 'three'];
var arr2 = ['one', ...arr1, 'four', 'five'];
```

**2.复制数组**

```javascript
var arr = [1,2,3];
var arr2 = [...arr]; // 就像 arr.slice()
arr2.push(4)

```
**3.结构赋值**

```javascript
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
console.log(x); // 1
console.log(y); // 2
console.log(z); // { a: 3, b: 4 }

```