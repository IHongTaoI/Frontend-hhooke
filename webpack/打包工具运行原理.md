前端模块化成为主流的今天，离不开各种打包工具的贡献，社区里对于webpack,rollup,以及后起之秀parcel的介绍层出不穷，为了避免成为一名“配置工程师”，我们需要来了解一下打包工具的原理，只有把核心原理搞明白了，在工具的使用上才能更加的得心应手。

## 1.打包工具的核心原理

顾名思义，打包工具就是负责把一些分散的小模块，按照一定的规则整合成一个大模块的工具。与此同时，打包工具也会处理好模块之间的依赖关系，最终这个大模块可以被运行在合适的平台中。 

打包工具会从一个入口文件开始，分析它里面的依赖，并且再进一步分析依赖中的依赖，不断重复这个过程，直到把这些依赖关系理清挑明为止。

从上面的描述可以看到，打包工具最核心的部分，其实就是处理好模块之间的依赖关系。

为了简单起见，项目中直接使用ESmodules规范，接下来我们新建三个文件，并且为他们之间建立依赖。

```javascript
/* name.js */
export const name = "hongtao";
```

```javascript
/* message.js */
import { name } from "./name";
export default `你好 ${name}`;
```

```javascript
/* entry.js */
import message from './message.js';
console.log(message);
```
他们之间的依赖关系非常简单 entry -> message -> name,其中 entry将会成为打包工具的入口文件。

##2.依赖关系解析

新建一个js文件，命名为 minipack.js，引入必要的工具。
```js
/* minipack.js */
const fs = require('fs')
const path = require('path')
const babylon = require('babylon')
const traverse = require('babel-traverse').default
const { transformFromAst } = require('babel-core')
```

接下来我们写一个函数，这个函数接受一个文件作为模块。然后读取他里面的内容。分析出所有的依赖项。当然，我们可以通过正则匹配模块里的inport关键字，但这样做非常不优雅，所以我们可以使用babylon这个js解析器把文件内容转化成抽象的语法树(AST),直接从AST里面获取我们需要的信息。

得到AST后就可以使用babel-traverse去遍历这棵AST，获取当中关键的“依赖声明”，然后把这些依赖都保存在一个数组当中。

最后使用babel-core的transformFromAst方法搭配babel-preset-env插件，把es6语法转化成浏览器可以识别的es5语法，并且为该模块分配一个ID。

```js
let ID = 0
function createAsset (filename) {
    // 读取文件内容
    const content = fs.readFileSync(filename,'utf-8')

    //转化成AST
    const ast = babylon.parse(content.{
        sourceType : 'module'.
    })

    // 该文件所有的依赖
    const dependencies = []

    //获取声明依赖
    traverse(ast,{
        ImportDeclaration: ({node}) => {
            dependencies.push(none.source.value)
        }
    })
    
    //转化ES6语法到ES5
    const {code} = tranformFromAst(ast, null, {
        presets: ['env'],
    })

    //分配ID
    const id = ID++

    //返回这个模块
    return {
        id,
        filename,
        dependencies,
        code,
    }
}
```

> 运行 creatAsset('./example/entry.js'),输出如下

```json
{
    id: 0,
    filename: [],
    dependencies: ['./message.js'],
    code: '"use strict";\n\nvar _message = require("./message.js");\n\nvar _message2 = _interopRequireDefault(_message);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconsole.log(_message2.default);'
}
```
可见 entry.js文件已经变成了一个典型的模块，且依赖已经被分析出来了。接下来我们就要递归这个过程，把“依赖中的依赖”也都分析出来，也就是下一节要讨论的建立依赖关系图集。

## 3、建立依赖关系图集

新建一个名为 createGragh()的函数，传入一个入口文件的路径作为参数，然后通过 createAsset()解析这个文件使之定义成一个模块。

接下来，为了能够挨个挨个地对模块进行依赖分析，所以我们维护一个数组，首先把第一个模块传进去并进行分析。当这个模块被分析出还有其他依赖模块的时候，就把这些依赖模块也放进数组中，然后继续分析这些新加进去的模块，直到把所有的依赖以及“依赖中的依赖”都完全分析出来

与此同时，我们有必要为模块新建一个 mapping属性，用来储存模块、依赖、依赖ID之间的依赖关系，例如“ID为0的A模块依赖于ID为2的B模块和ID为3的C模块”就可以表示成下面这个样子：

```js
{
  0: [function A () {}, { 'B.js': 2, 'C.js': 3 }]
}
```
搞清楚了个中道理，就可以开始编写函数了。

```js
function creatGragh (entry) {
    // 解析传入的文件为模块
    const mainAsset = creatAsset(entry)

    // 维护一个数组，传入第一个模块
    const queue = [mainAsset]

    // 遍历数组，分析每一个模块是否还有其他依赖，若有则把依赖模块推进数组。
    for( const asset of queue ){
        asset.mapping = {}
        // 构造绝对路径
        const absolutePath = path.join(dirname, relativePath)
        // 生成依赖模块
        const child = createAsset(absolutePath)
        // 把依赖写入模块的mapping中
        asset.mapping[relativePath] = child.id
        // 把这个依赖模块也推入到queue数组中，以便继续对其进行以来分析
        queue.push(child)
    }
    // 最后返回这个queue，也就是依赖关系图集
    return queue
}
```
可能有读者对其中的 for...of ...循环当中的 queue.push有点迷，但是只要尝试过下面这段代码就能搞明白了：

```js
var numArr = ['1', '2', '3']
for (num of numArr) {
  console.log(num)
  if (num === '3') {
    arr.push('Done!')
  }
}
```
尝试运行一下 createGraph('./example/entry.js')，就能够看到如下的输出：
```js
[ { id: 0,
    filename: './example/entry.js',
    dependencies: [ './message.js' ],
    code: '"use strict";\n\nvar _message = require("./message.js");\n\nvar _message2 = _interopRequireDefault(_message);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconsole.log(_message2.default);',
    mapping: { './message.js': 1 } },
  { id: 1,
    filename: 'example/message.js',
    dependencies: [ './name.js' ],
    code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _name = require("./name.js");\n\nexports.default = "Hello " + _name.name + "!";',
    mapping: { './name.js': 2 } },
  { id: 2,
    filename: 'example/name.js',
    dependencies: [],
    code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nvar name = exports.name = \'world\';',
    mapping: {} } ]
```

现在依赖关系图集已经构建完成了，接下来就是把它们打包成一个单独的，可直接运行的文件啦！

## 4、进行打包

上一步生成的依赖关系图集，接下来将通过 CommomJS规范来实现加载。由于篇幅关系，本文不对 CommomJS规范进行扩展，有兴趣的读者可以参考@阮一峰 老师的一篇文章《浏览器加载 CommonJS 模块的原理与实现》，说得非常清晰。简单来说，就是通过构造一个立即执行函数 (function () {})()，手动定义 module， exports和 require变量，最后实现代码在浏览器运行的目的。

接下来就是依据这个规范，通过字符串拼接去构建代码块。

```js
function bundle (graph) {
  let modules = ''
  graph.forEach(mod => {
    modules += `${mod.id}: [
      function (require, module, exports) { ${mod.code} },
      ${JSON.stringify(mod.mapping)},
    ],`
  })
  const result = `
    (function(modules) {
      function require(id) {
        const [fn, mapping] = modules[id];
        function localRequire(name) {
          return require(mapping[name]);
        }
        const module = { exports : {} };
        fn(localRequire, module, module.exports);
        return module.exports;
      }
      require(0);
    })({${modules}})
  `
  return result
}
```

最后运行 bundle(createGraph('./example/entry.js'))，输出如下：

```js
(function (modules) {
  function require(id) {
    const [fn, mapping] = modules[id];
    function localRequire(name) {
      return require(mapping[name]);
    }
    const module = { exports: {} };
    fn(localRequire, module, module.exports);
    return module.exports;
  }
  require(0);
})({
  0: [
    function (require, module, exports) {
      "use strict";
      var _message = require("./message.js");
      var _message2 = _interopRequireDefault(_message);
      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      console.log(_message2.default);
    },
    { "./message.js": 1 },
  ], 1: [
    function (require, module, exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _name = require("./name.js");
      exports.default = "Hello " + _name.name + "!";
    },
    { "./name.js": 2 },
  ], 2: [
    function (require, module, exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var name = exports.name = 'world';
    },
    {},
  ],
})
```

这段代码将能够直接在浏览器运行，输出“Hello world!”。

至此，整一个打包工具已经完成。